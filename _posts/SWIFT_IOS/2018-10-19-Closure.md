---
layout: post
title:  Closure
date:  2018-10-19 23:47:46
category: SwiftIos
tags: [Swift,Closure]
---



# 클로저 (Closure)



### 클로저 모양

```swift
{(parameters)->return type in
    //statements
}
```



### 예제 (공식 문서에서 가져옴)

```swift
let names = [ "Chris", "Alex", "Ewa", "Barry", "Daniella" ]

var sorted = sort(names)
// sorted = ["Alex", "Barry", "Chris", "Daniella", "Ewa"]


func backwards(s1: String, s2: String) -> Bool {
    return s1 > s2
}

var reversed = sort(names, backwards)
// reversed = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]

reversed = sort(names, 
                { (s1: String, s2: String) -> Bool in return s1 > s2 } )
// reversed = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

더 단축해볼까?

```swift
reversed = sort(names, { s1, s2 in return s1 > s2 })
```

앞서 본 reversed에 사용된 클로져를 훨씬 간단하게 단축시켰다. 이 형식은 컨텍스트에 따라 타입을 유추하여 동작하는 방식이다. 물론 정확하게 말하자면 유추한다라기 보다는, 애초에 

이 클로져가 사용된 sort 함수의 두 번째 인자에는 함수 매개변수 및 리턴 타입에 대해 이미 정의가 되어 있기 때문에 이를 근거로 클로져에 사용되는 매개변수와 리턴 타입을 자동으로 적용

하는 것이다. 따라서 유추하는데 모호하면 어떡하냐는 걱정은 필요가 없다.

그런데 여기서 더 단축시키는 방법도 있다. 리턴(return) 자체를 묵시적(implicit)으로 바꿔버리는 것이다. 쉽게 말해서 return 자체도 필요가 없다는 뜻이다. 

```
reversed = sort(names, { s1, s2 in s1 > s2 })
```

여기서 return을 뺄 수 있는건 논리적 비교가 수행되는 

```
s1 > s2
```

 라는 문장이 Bool 이라는 타입의 데이터를 생성하기 때문이다. 보통 클로져를 sort 에서 쓰는 용도처럼 '클로져 몸뚱아리가 리턴하는 값을 활용'하는 형태로 많이 쓰기 때문에 특정한 타입의 데이터가 최종적으로 명시만 된다면 return을 생략 할 수가 있다.

이제는 약간 다른 클로져 문법을 보자. 이 방식은 별도의 중괄호로 클로져를 구현하는데 구현할 내용이 길어질 때 유용하게 쓸 수 있는 방식이다.

```
reversed = sort(names) { $0 > $1 }
```

끝자락에 붙는 클로져(Trailing Closure)라 불리는 형식이다. 이 방식은 약간 제한이 있는데, 

함수의 클로져 매개변수가 가장 마지막에 올 때 쓸 수 있는 문법

이라는 제한이다. sort() 함수의 경우 클로져를 가장 마지막 매개변수에 쓸 수 있게 정의되어 있기에 가능하다. 단지 매개변수 이름이 $0 부터 시작해서 $1, $2 ... 와 같은 식으로 순서를 메겨서 구현한다는 점이 좀 다르다.

함수를 만들어내는 함수

함수 속의 함수(Nested Function)은 단순히 '함수 안에서 정의하는 함수'로도 볼 수 있다. 하지만 '함수 속에 선언된 함수'는 부모(?) 함수가 실행될 때 만들어지기 때문에 클로져의 또다른 형식이기도 하다. 

```
func factory(str: String) -> () -> String {
    func simpleStringFunc() -> String {
        var myString = str
        return myString
    }
    return simpleStringFunc
}

var strA = factory("A")
var strB = factory("B")
println(strA())        // 콘솔에 A 출력
println(strB())        // 콘솔에 B 출력
```

위 예제의 factory() 함수는 '인자로 전달된 문자열을 리턴하는 함수'를 리턴한다. 리턴 타입을 잘 보면 

```
() -> String
```

이라는 함수의 형식과 비슷한 타입을 취하고 있는데 이는 함수를 리턴한다는 의미이다. 내부에서는 simpleStringFunc 라는 인자로 전달된 str를 특정 변수에 넣은 후 이를 리턴하는 함수를 생성한다. 그리고 생성한 함수를 리턴한다.

리턴된 함수를 변수(strA, strB)에 할당해서 이 변수를 함수처럼 실행시키는 것도 가능하다. 마치 자바스크립트와 비슷하다.

이번에는 함수 내부의 변수와 함수 속의 함수간의 관계에 대해 알아보자. 아래 예제의 incrementFunc() 는 실행 될 때 마다 0에서 특정 수치를 증가시키는 클로져 함수를 리턴하는 함수다. 

```
func incrementFunc(incValue: Int) -> () -> Int {
    var parentValue = 0
    func nestedFunc() -> Int {
        parentValue += incValue
        return parentValue
    }
    return nestedFunc
}

var inc10 = incrementFunc(10)
inc10()      // 10
inc10()      // 20
inc10()      // 30
inc10()      // 40
inc10()      // 50

var inc20 = incrementFunc(20)
inc20()      // 20
inc20()      // 40
inc20()      // 60
inc20()      // 80
inc20()      // 100
```

incrementFunc()를 이용해 생성된 클로저 함수를 두 개의 변수 inc10과 inc20에 담았고 이를 별도로 실행시켰다. 실행 결과는 주석으로 표기한 것이다. 그냥 코드를 얼핏 읽어보면 이런 식의 결과가 나올 것 같진 않지만 결론적으로 둘은 따로 동작하지만 결과를 내부에 계속 보관하고 있다.  

동적으로 생성된 함수(Nested Function)나 클로져는 생성 당시 시점의 데이터를 모두 복사해서 사라지기 전 까진 보관한다. incrementFunc의 경우 parentValue가 0으로 초기화 되고 별 다른 사용이 없는데 따라서 incrementFunc 함수가 실행될 때는 항상 parentValue가 0이다. nestedFunc() 는 parentValue를 가지고 내부에서 이 값을 증가시켜서 리턴하는 구조다.

결과적으로 inc10 과 inc20은 같은 함수에서 생성되었지만 서로 다른 메모리를 가지고 있다는 점이다. 클로져는 동적으로 생성되는 함수이고 생성 당시의 주변의 값(?)을 몽땅 복사해서 가지고 시작한다. 클로져가 아닌 일반적인 함수라면 static 같은 정적 변수가 아니고서는 비슷하게 흉내내기 힘든 특징이다.

@autoclosure

설명으로는 암시적인 클로져를 생성한다고 하는데 뭐가 다른지는 잘 모르겠다. 어쨌든 예제를 보자. 

```
func matchWithClosure(closure: @autoclosure () -> Bool, p: Bool) -> Bool {
    return (closure() == p)
}

let v = 10
matchWithClosure(v + v == v * 2, true)    // true
matchWithClosure(v + v == v * 2, false)   // false
```

오토클로져는 매개변수 타입 앞에 

```
@auto_closure
```

를 붙임으로써 정의가 가능하다. 단 

오토클로져는 매개변수를 가질 수 없다

는 제약이 있다.

특정 수식을 넘기면 이를 클로져 형식으로 바꾼뒤 넘어가는 형식 같은데 어떻게 써 먹어야 할지를 모르겠다는게 단점같다. -_-;;



어떻게 쓰는지는 

@autoclosure 이야기

 글을 보자.

참고) @auto_closure 가 @autoclosure 로 이름이 변경되었다.

변수나 상수에 직접 클로져 담기

자바스크립트 처럼 변수에 바로 함수를 할당하는 방식과 비슷하게 클로져를 팩토리 함수가 아닌 방법으로 만들 수 있을까 해서 해 봤는데, 결론적으로 아래와 같은 방식으로는 성공하였다. 

```
let myClosure: (Int, Int) -> Int = {
    return $0 + $1
}
myClosure(1, 2)       // 3
```

문법이 헷갈릴 수도 있지만, 타입 대신 클로져를 정의하는 스타일을 넣어서 몸뚱아리를 대입시키는 방식이다. 자바스크립트가 연상되어서 참 난감하다. -_-;;

그나저나 이렇게 클로져를 만들 때는 매개변수 이름을 줄 수 없다는 또 다른 단점이 있다. 주의하자.

필요하다면 타입 별칭을 만들어서 클로져 대량 양산(?)의 꿈을 키우는 것도 가능하다.

```
typealias MyClosureType = (Int, Int) -> Int
let myClosure: MyClosureType = {
    return $0 + $1
}
```

앞의 예제와 동일하고 단지 타입 정의 부분만 typealias로 분리해 낸 예제이다. 아마도 이런 스타일은 종종 쓰일지도 모르겠다.



클로져 이용 시에도 메모리 관리와 관련된 지식이 필요 할 때가 있다. 일반적인 변수 대입 과정에서 리테인이 발생하는 요소 외에도 클로져 내부에서 외부의 변수를 참조 할 때 발생하는 리테인을 깜빡 할 수도 있기 때문이다.



캡쳐 리스트 (Capture List)

이 블로그에서 클로져의 캡쳐리스트에 관해 언급한 적이 없어서 일단 짚고 넘어가야 할 것 같다. 우선은 왜 이런게 필요한 상황이 오는지 부터 살펴보자.

클로져는 아래 예 같은 문제가 있을 수도 있다. 

```
var funcs: [() -> Int] = []
for var i=0; i < 10; i++ {
    funcs.append({
        () in
        return i
    })
}

funcs[0]()  // 10
```

마지막 라인의 결과가 생각과는 다르게 0이 아니라 10이 나온다. 다른 모든 인덱스를 넘겨봐도 모두 10이 나올 것이다.

이유는 단순한데, i 라는 인스턴스가 고정되어 있기 때문이다. 즉 하나의 정수 인스턴스를 만들고 이 인스턴스의 값을 0에서 9 까지 바꾸어가며 클로져를 생성하기 때문에 모든 클로져는 하나의 i 인스턴스 만으로 생성된다. 그래서 클로져 내부에서 참조하는 i는 for루프 탈출 조건인 i가 10이 된 순간의 값만이 복사되어 있다.

> 혹시 [앞서 이야기한 struct와 class의 차이에서 struct는 인스턴스를 만들어서 복사한다](http://seorenn.blogspot.kr/2015/01/swift-memory-management-3-struct-class.html)는걸 여기서 생각한다면 잘못된 생각이다. struct는 대입 과정에서만 인스턴스를 새로 생성한다.

여기서 추가로 알아야 할 사항은 클로져 내부에서 참조하는 외부 변수는 모두 강하게 참조(strong)하게 된다는 점이다. 위에서 생성되는 모든 클로져는 i에 리테인을 건다. 그리고 해당 클로져가 모두 사라지기 전 까지 for 루프에서 생성된 i 라는 지역변수는 메모리에서 해제되지 않는다.

이제 문제를 해결해 보자.

이 문제를 해결하려면 클로져 생성 당시의 i의 값을 캡쳐(Capture) 해야한다. Swift에서는 이런 기능을 캡쳐리스트(Capture List) 라는 이름으로 제공한다. 클로져 파라미터 선언 앞에 대괄호로 묶어서 변수 이름을 적어주면 된다. 

```
var funcs: [() -> Int] = []
for var i=0; i < 10; i++ {
    funcs.append({
        [i] () in     // i의 값을 캡쳐한다.
        return i
    })
}

funcs[0]()  // 0
```

이제 의도한 대로 마지막 라인의 결과는 0이다. 각 인덱스를 순환해보면 제대로 된 값을 돌려줌을 확인 할 수 있을 것이다.

캡쳐리스트에 선언된 i는 클로져가 생성될 때 클로져 내부에 복사가 발생한다. 여기서 i는 Int 즉 정수형을 의미하는 구조체(struct) 타입이다. 따라서 클로져 생성 순간에 정수 인스턴스가 새롭게 생성되어 i의 값을 복사한 후 이 새 인스턴스에 리테인을 거는 식으로 동작한다. 이제 for 루프에 의해 생성된 i는 클로져와 상관 없이 메모리에서 해제가 가능해진다.

> 만약 Int 타입이 struct가 아닌 class로 만들어져 있었다면 캡쳐리스트를 써도 해결이 안되었을 것이다. 왜 그런지는 직접 생각해 보자.

참고로 위의 문제는 캡쳐리스트를 쓰지 않고도 해결하는 방법이 있다. for 루프를 아래와 같은 식으로 바꾸면 된다. 

```
for i in 0..<10 {
    ...
}
```

이유는 단순하다. 위의 식으로 바꾸면 i라는 값은 0에서 9 까지 별개의 정수 인스턴스가 들어가게 된다. for문에서 Range를 사용하게 되면 매 아이템이 새로운 인스턴스로 생성되기 때문이다. 그래서 캡쳐리스트가 필요 없어진다. 물론 이와 동일하게 블럭 내부에서 i값을 복사한 새로운 인스턴스를 생성하면 문제는 해결된다.

약한 self?

이제 실제로 메모리 관리와 관련된 이슈를 보자. Objective-C 에서 블럭 프로그래밍을 해 봤다면 weak self(혹은 unsafe Unretained self) 라는 개념에 대해 들어 본 적이 있을지도 모르겠다. Swift도 ARC를 쓰기 때문에 비슷한 용도의 단어가 등장하는게 그것디 바로 약한 참조의 self(weak self 혹은 unowned self)이다.

아래 예제를 보자. 

```
class SomeClass {
    let name: String
   
    init(name: String) {
        self.name = name
    }
   
    lazy var someClosure: () -> String = {
        () in
        return self.name
    }
}

let some1 = SomeClass(name: "Some 1")
let cl = some1.someClosure
cl()
```

이 코드 만으로 문제를 찾자는 것은 아니다. 일단 설명이 필요할 것 같다.

cl 이라는 상수는 some1 오브젝트에서 someClosure 라는 lazy한 프로퍼티 getter를 통해 클로져를 생성해서 받는다. (위 예제에서는 굳이 lazy로 할 필요는 없다. 다만 생성자가 아닌 곳에서 name의 값을 바꾸게 되는 경우를 대비하기 위함이다)

이 cl이 받게되는 클로져는 생성될 때 self를 참조하기 때문에 self에 리테인을 건다(즉 self를 강하게(strong) 참조한다). 그래서 cl이 메모리에서 해제되기 전 까지 some1 이라는 오브젝트 인스턴스(클로져 내부에서 self)도 리테인에 묶이게 되어서 메모리가 해제되지 않는다.

그렇다면 문제가 되는 케이스가 있다면? 만약 cl이 이런 지역 변수가 아니라 특정 클래스의 strong 프로퍼티였다면 어떻게 될까. 예를 들어 iOS 앱의 중추 클래스인 AppDelegate의 프로퍼티 중에 위의 cl같은 녀석이 있다면 어떻게 될까. 앱이 종료되기 전 까지 some1 같은 인스턴스가 영원히 해제되지 않는다는 말이 된다.

물론 이런 특수한 케이스의 경우에만 문제가 된다. 아니 사실 문제는 아니다. 왜냐하면 위에서 리테인을 건 self는 cl이 살아있는 한 언제든지 참조가 가능해야 되니 결코 메모리에서 해제되어서는 안된다. 따라서 정상적인 동작으로 봐야 한다.

만약 위의 경우에서 SomeClass의 인스턴스인 some1이 메모리에서 해제되어야만 하는 경우가 있다면 캡쳐리스트를 이용 할 수 있다. someClosure 프로퍼티의 구현을 아래처럼 바꾸면 된다. 

```
class SomeClass {
    ...
    lazy var someClosure: () -> String = {
        [unowned self] () in
        return self.name
    }
    ...
}
```

이제 someClosure로 받게되는 클로져가 내부에서 참조하는 self는 unowned가 되었다. 사실 이는 weak self와 비슷한 의미인데, weak의 경우 Optional이 되어야 한다. Swift에서 옵셔널 처리는 문법상 좀 귀찮으니 일부러 unowned를 썼다고 치자. 원한다면 weak로 명시하고 nil 확인을 할 수도 있다.

> unowned의 경우 unsafe unretained 라는 표헌을 쓰기도 하는데, nil이 될 수 없기 때문에 메모리에서 해제되었는지 여부를 파악 할 수가 없기 때문이다. 안전하게 구현하려면 unretained 라는 표현으로 불리는 weak를 써서 nil 체크를 하는 것이 좋다.

어쨌든 이제 cl이 살아있어도 some1 인스턴스는 해제되는 것이 가능하다.

마무리

명확하게 문제가 되는 예제를 보여주고 싶지만, 억지로 그런 예제를 만드는 건 뭔가 아닌 것 같다. 그래서 이번에는 그냥 문제가 될 만한 상황을 글로만 정리를 했다. 예제가 없는건 너무 아쉽지만 내 예제코드 작성 능력의 한계는 여기까지 인 것 같다.

코드 작성 방법에 따라 이런 weak self 같은건 쓸 일이 없을지도 모른다. 사실 내 경우도 위와 같이 클로져를 남이 실행시킬 수 있게 던져주는 걸 굉장히 싫어한다. 그래서 모르는 것 보다야 낫지 않을까.